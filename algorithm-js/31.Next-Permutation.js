// 31. 下一个排列
// 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
// 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
// 必须 原地 修改，只允许使用额外常数空间。

// 示例 1：
// 输入：nums = [1, 2, 3]
// 输出：[1, 3, 2]

// 示例 2：
// 输入：nums = [3, 2, 1]
// 输出：[1, 2, 3]

// 示例 3：
// 输入：nums = [1, 1, 5]
// 输出：[1, 5, 1]

// 示例 4：
// 输入：nums = [1]
// 输出：[1]

// 提示：
// 1 <= nums.length <= 100
// 0 <= nums[i]     <= 100

// 算法思路：
// 注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。
// 我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。
// 具体地：
// 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，
// 以能够让当前排列变大，从而得到下一个排列。
// 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。
// 当交换完成后，「较大数」右边的数需要按照升序重新排列。
// 这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

// 以排列[4, 5, 2, 6, 3, 1]为例：
// 我们能找到的符合条件的一对「较小数」与「较大数」的组合为2与3，
// 满足「较小数」尽量靠右，而「较大数」尽可能小。
// 当我们完成交换后排列变为[4, 5, 3, 6, 2, 1]，此时我们可以重排「较小数」右边的序列，
// 序列变为[4, 5, 3, 1, 2, 6]

// 具体地，我们这样描述该算法，对于长度为n的排列a：
// 首先从后向前查找第一个顺序对(i, i + 1)，满足 a[i] < a[i + 1]。
// 这样「较小数」即为a[i]。此时[i + 1, n - 1]必然是下降序列。
// 如果找到了顺序对，那么在区间[i + 1, n - 1]中从后向前查找第一个元素j满足a[i] < a[j]。
// 这样「较大数」即为a[j]。
// 交换a[i]与a[j]，此时可以证明区间[i + 1, n - 1]必为降序。
// 我们可以直接使用双指针反转区间[i + 1, n - 1]使其变为升序，而无需对该区间进行排序。
// 如果整个序列遍历结束都没有找到符合条件的i，则说明这个序列是完全降序排列的，并且是最大序列
// 按照题意，其下一个序列则是最小序列，我们只需对其进行翻转即可（双指针翻转）
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */

// 交换数组元素必须传入数组，否则，不会改变数组内元素的顺序
// 因为传递数组传递的是数组的索引，传递数组元素值传递的是数组元素值的拷贝
const swap = function (indexLeft, indexRight, arr) {
  const tmp = arr[indexLeft]
  arr[indexLeft] = arr[indexRight]
  arr[indexRight] = tmp
}
const reverseList = function (start, end, nums) {
  while (start < end) {
    swap(start, end, nums)
    start++
    end--
  }
}
const nextPermutation = function (nums) {
  const len = nums.length
  let i
  for (i = len - 2; i >= 0; i--) {
    if (nums[i] < nums[i + 1]) {
      // 从i到len-1寻找大于nums[i]的值，
      // 因为nums[i + 1, len-1]为降序，因此第一个找到的大于nums[i]的值就是较小的大值
      for (let j = len - 1; j > i; j--) {
        if (nums[i] < nums[j]) {
          swap(i, j, nums)
          // 反转区间[i + 1, len - 1]
          reverseList(i + 1, len - 1, nums)
          return
        }
      }
    }
  }
  // 当最外层循环遍历结束，则表明序列是完全降序的，
  // 是最大序列，此时将序列反转为最小序列即可
  // 最外层循环遍历结束则i为-1
  if (i === -1) {
    reverseList(0, len - 1, nums)
  }
}
const arr = [1, 2, 3]
console.log(arr)
nextPermutation(arr)
console.log(arr)
