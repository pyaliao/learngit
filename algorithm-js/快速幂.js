// 一、普通求幂

const firstPow = function (m, n) {
  let result = 1
  for (let i = 1; i <= n; i++) {
    result *= m
  }
  return result
}
console.log(firstPow(2, 60))

// 二、递归快速幂
// 快速幂原理：m^n，按照朴素算法，需要遍历n次，时间复杂度为O(n)
// 而n可以拆分为n/2，我们只需要计算出m^(n/2)，在对其进行一次平方即可得到m^n，这种运算共进行了n/2+1次
// 我们按此原理继续拆分，知道n被拆分为1，我们计算出m，对其进行平方计算出m^2，对m^2进行平方得到m^4
// 一直到计算出m^n，可以看出来，m的指数呈指数增长，即m的指数从1, 2, 4, 8, ..., n，可以看出只需要一直进行
// 平方运算，就可以得到m^n，而平方运算的次数为logn，那么我们就把算法复杂度从朴素算法的O(n)降到快速幂的O(logn)
const recursivePow = function (m, n) {
  if (n === 0) {
    return 1
  } else if (n % 2 === 1) {
    return recursivePow(m, n - 1) * m
  } else {
    const temp = recursivePow(m, n / 2)
    return temp * temp
  }
}
console.log(recursivePow(2, 100))

// 三、非递归快速幂
// 非递归快速幂一般用位运算实现
// 每次遍历时，先计算后最低位对应的m的幂，然后判断最低位是否为1，如果为1说明最低位对应的幂应该被乘到结果中
// 如果最低位不为1，说明对地位对应的幂值不需要被乘入结果中，因此什么也不做，只需要对当前幂值进行平方求出新的幂值
// 然后将n右移一位，以丢弃当前最低位，使新的幂值与新的最低位对应
// 如此循环直到n为0，此时退出循环，返回结果
// m^10 = m^(1010) = m^(0*2^0 + 1*2^1 + 0*2^2 + 1*2^3) = m^(0*2^1) * m^(1*2^1) * m^(0*2^2) * m^(1*2^3)
// 可以看出来从最低位开始到最高位对应的幂分别是2^0，2^1,  2^2, 2^3即1, 2, 4, 8，呈现平方增长，而其系数0或者1由
// n的每一位决定。因此每次循环对m进行平方得到对应位对应的幂值，然后根据n最后一位是否为1来决定是否将对应的m的幂值
// 计算到结果中，最后将n右移一位，让最后一位与新计算的m的幂值对应起来即可
// 因为第一次计算时，m对应的幂是1，因此直接判断n&1的值来决定是否将其计算进结果
// 然后更新m的幂值，将n右移一位，进入下一轮循环，知道n为0，退出循环，计算结束
const pow = function (m, n) {
  let ans = 1
  while (n) {
    if (n & 1) {
      ans *= m
    }
    m *= m
    n >>= 1
  }
  return ans
}
console.log(pow(3, 30))
