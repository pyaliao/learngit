## 36. 有效的数独

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）。

数独部分空格内已填入了数字，空白格用 '.' 表示。

>注意：
> * 一个有效的数独（部分已被填充）不一定是可解的。
> * 只需要根据以上规则，验证已经填入的数字是否有效即可。

示例 1：

![示例一](./img/36.Valid-Sudoku.png)

```js

  输入：board = 
  [["5","3",".",".","7",".",".",".","."]
  ,["6",".",".","1","9","5",".",".","."]
  ,[".","9","8",".",".",".",".","6","."]
  ,["8",".",".",".","6",".",".",".","3"]
  ,["4",".",".","8",".","3",".",".","1"]
  ,["7",".",".",".","2",".",".",".","6"]
  ,[".","6",".",".",".",".","2","8","."]
  ,[".",".",".","4","1","9",".",".","5"]
  ,[".",".",".",".","8",".",".","7","9"]]

 `输出：true`

```

示例 2：

```js

输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

`输出：false`

`解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。`

```

> 提示：
> * board.length == 9
> * board[i].length == 9
> * board[i][j] 是一位数字或者 '.'

&nbsp;
&nbsp;
### 算法思路
在一次循环中检测行、列及子数独是否有效。将每次遍历到的数值及其数量作为键值对存储到map，每次遍历都更新响应数值的个数。更新后判断是否大于1，如果大于1，则说明数独无效直接返回false，否则进行下一次循环。
当循环遍历结束，则说明数独有效，返回true即可。

* 如何确保行 / 列 / 子数独中没有重复项？  
可以利用 value -> count 哈希映射来跟踪所有已经遇到的值。
* 如何枚举子数独？  
  可以使用 box_index = (row / 3) * 3 +columns / 3，其中 / 是整数除法。

  ![示例一](img/36.Valid-Sudoku-Child.png)

现在，我们完成了这个算法的所有准备工作：

* 遍历数独。
* 1. 检查看到每个单元格值是否已经在`行/列/子数独`中出现过：如果出现返回 false。
  2. 如果没有，则保留此值以进行进一步跟踪。
* 返回 true。
