// 44. 通配符匹配
// 给定一个字符串(s)和一个字符模式(p)，实现一个支持'?'和'*'的通配符匹配。

// '?'可以匹配任何单个字符。
// '*'可以匹配任意字符串（包括空字符串）。
// 两个字符串完全匹配才算匹配成功。

// 说明:
// s可能为空，且只包含从a - z的小写字母。
// p可能为空，且只包含从a - z的小写字母，以及字符 ? 和 *。

// 示例1:
// 输入:
// s = "aa"
// p = "a"
// 输出: false
// 解释: "a"无法匹配"aa"整个字符串。

// 示例2:
// 输入:
// s = "aa"
// p = "*"
// 输出: true
// 解释: '*'可以匹配任意字符串。

// 示例3:
// 输入:
// s = "cb"
// p = "?a"
// 输出: false
// 解释: '?'可以匹配'c', 但第二个'a'无法匹配'b'。

// 示例4:
// 输入:
// s = "adceb"
// p = "*a*b"
// 输出: true
// 解释: 第一个'*'可以匹配空字符串, 第二个'*'可以匹配字符串"dce".

// 示例5:
// 输入:
// s = "acdcb"
// p = "a*c?b"
// 输出: false

// 方法一、使用动态规划
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
const isMatch = function (s, p) {
  const sLen = s.length
  const pLen = p.length
  // 定义dp数组
  const dp = []
  // dp[i][j]表示s的前i个字符组成的子串与p中前j个字符组成的子串是否匹配
  // 将dp初始化为一个二维数组，默认将所有值初始化为false
  for (let i = 0; i <= sLen; i++) {
    dp[i] = []
    for (let j = 0; j <= pLen; j++) {
      dp[i][j] = false
    }
  }
  // p[j - 1]代表匹配模式的第j个字符，s[i - 1]代表被匹配字符串的第i个字符，因为数组下标是从0开始的
  // dp[i][j]代表表示字符串s的前i个字符和模式p的前j个字符是否能匹配，i j是从1开始的
  // dp[i][0]：边界条件：匹配模式为空时，与字符串不匹配，恒为false，初始化已经将其置为false了
  // dp[0][0]：边界条件：当字符串和匹配模式均为空，则匹配成功
  dp[0][0] = true
  // dp[0][j]：边界条件：当匹配模式中j及之前的所有字母都为*，dp[0][j]才能匹配成功
  for (let j = 1; j <= pLen; j++) {
    // 数组下标是从0开始的，因此要减去1
    if (p[j - 1] === '*') {
      // dp[0][j]中j代表前j个字符，因此不需减1
      dp[0][j] = true
    } else {
      // *必须是连续的，如果中断了则直接退出
      break
    }
  }
  // 上面处理了所有的边界条件以及不满足状态转义方程的其他情况（置为false）
  // 1. 如果 p[j - 1]是小写字母，那么 s[i - 1]必须也为小写字母，状态转移方程为：
  // dp[i][j]=(s[i - 1] === p[j - 1]) && dp[i−1][j−1]，
  // 即当s[i - 1] === p[j - 1]时，dp[i][j]的真假由dp[i−1][j−1]决定
  // 当s[i - 1] !== p[j - 1]时，肯定是不匹配的，值为false，这种情况在初始化已经处理
  // 2. 如果p[j - 1]是问号，那么对s[i - 1]没有任何要求，状态转移方程为:
  // dp[i][j] = dp[i−1][j−1]，dp[i][j]的真假由dp[i−1][j−1]决定
  // 3. 如果p[j - 1]是星号，那么同样对s[s - 1]没有任何要求
  // 但是星号可以匹配零或任意多个小写字母，因此状态转移方程分为两种情况，
  // 即使用或不使用这个星号，
  // 3.1 如果我们不使用这个星号，那么dp[i][j]就会从dp[i][j-1]转移而来
  // dp[i][j] = dp[i][j - 1] || dp[i - 1][j]
  // 3.2 如果我们使用这个星号，那么就会从dp[i-1][j]转移而来。此处有推断：
  // 如果p[j - 1]是星号，可匹配任意长度的字符，可以匹配 0 个字符、匹配 1 个字符、匹配 2 个字符
  // 3.1.当匹配为 0 个：dp[i][j] = dp[i][j - 1]
  // 3.2.当匹配为 1 个：dp[i][j] = dp[i - 1][j - 1]
  // 3.3.当匹配为 2 个：dp[i][j] = dp[i - 2][j - 1]
  // ...
  // 3.k.当匹配为 k 个：dp[i][j] = dp[i - k][j - 1]
  // 由上面的公式可以看出，dp[i][j]的值是由
  // dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 2][j - 1] || ... || dp[i - k][j - 1](i >= k)
  // 决定的，因为只要其中一项为true(即匹配)，则dp[i][j]为true，否则为false，因此：
  // dp[i][j] = dp[i][j - 1] || dp[i - 1][j - 1] || dp[i - 2][j - 1] || ... || dp[i - k][j - 1](i >= k)
  // 将上面公式中的i换为i-1，则:
  // dp[i - 1][j] = dp[i - 1][j - 1] || dp[i -2][j - 1] || ... || dp[i - k][j - 1] || dp[i - 1 - k](i >= k)
  // 因为i>=k，dp[i - 1 - k]不存在，因此
  // dp[i - 1][j] = dp[i - 1][j - 1] || dp[i -2][j - 1] || ... || dp[i - k][j - 1](i >= k)
  // 结合两个公式可得：dp[i][j] = dp[i][j - 1] || dp[i - 1][j]
  for (let i = 1; i <= sLen; i++) {
    for (let j = 1; j <= pLen; j++) {
      // 数组下标是从0开始的，因此为下标要减一
      // 当pj为*号时
      if (p[j - 1] === '*') {
        dp[i][j] = dp[i][j - 1] || dp[i - 1][j]
      } else if (s[i - 1] === p[j - 1] || p[j - 1] === '?') {
        // 当p[j - 1]为?或者p[j - 1]等于s[i - 1]时
        dp[i][j] = dp[i - 1][j - 1]
      } // 当p[j - 1]不等于s[i - 1]时，不匹配，为false，初始化已经做了处理，因此不再做处理
    }
  }
  return dp[sLen][pLen]
}

// 时间复杂度：O(mn)，其中m和n分别是字符串s和模式p的长度。
// 空间复杂度：O(mn)，即为存储所有(m + 1)(n + 1)个状态需要的空间。
// 此外，在状态转移方程中，由于dp[i][j]只会从dp[i][..]以及dp[i - 1][..]转移而来，
// 因此我们可以使用滚动数组对空间进行优化，即用两个长度为 n + 1 的一维数组代替整个二维数组进行状态转移
// 空间复杂度为O(n)。
