// 41. 缺失的第一个正数
// 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
// 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

// 示例 1：
// 输入：nums = [1, 2, 0]
// 输出：3

// 示例 2：
// 输入：nums = [3, 4, -1, 1]
// 输出：2

// 示例 3：
// 输入：nums = [7, 8, 9, 11, 12]
// 输出：1

// 提示：
// 1 <= nums.length <= 5 * 105
// - 231 <= nums[i] <= 231 - 1

/**
 * @param {number[]} nums
 * @return {number}
 */

// 如果本题没有额外的时空复杂度要求，那么就很容易实现：
// 1. 我们可以将数组所有的数放入哈希表，随后从1开始依次枚举正整数，并判断其是否在哈希表中；
// 2. 我们可以从1开始依次枚举正整数，并遍历数组，判断其是否在数组中。

// 如果数组的长度为N，那么第一种做法的时间复杂度为O(N)，空间复杂度为O(N)；
// 第二种做法的时间复杂度为O(N^2)，空间复杂度为O(1)。
// 但它们都不满足时间复杂度为O(N)且空间复杂度为O(1)。

// 「真正」满足时间复杂度为O(N)且空间复杂度为O(1)的算法是不存在的，
// 但是我们可以退而求其次：利用给定数组中的空间来存储一些状态
// 也就是说，如果题目给定的数组是不可修改的，那么就不存在满足时空复杂度要求的算法；
// 但如果我们可以修改给定的数组，那么是存在满足要求的算法的。

// 方法一：哈希表
// 对于「前言」中提到的第一种做法：
// 我们可以将数组所有的数放入哈希表，随后从1开始依次枚举正整数，并判断其是否在哈希表中。
// 仔细想一想，我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：
// 给定一个元素，我们可以在O(1)的时间查找该元素是否在哈希表中。
// 因此，我们可以考虑将给定的数组设计成哈希表的「替代产品」。
// 实际上，对于一个长度为N的数组，其中没有出现的最小正整数只能在[1, N + 1] 中。
// 这是因为如果[1, N]都出现了，那么答案是N + 1，否则答案是[1, N]中没有出现的最小正整数。
// 这样一来，我们将所有在[1, N]范围内的数放入哈希表，也可以得到最终的答案。
// 而给定的数组恰好长度为N，这让我们有了一种将数组设计成哈希表的思路：
// 我们对数组进行遍历，对于遍历到的数x，如果它在[1, N]的范围内，那么就将数组中的第x−1个位置
// （注意：数组下标从0开始）打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，
// 那么答案是N + 1，否则答案是最小的没有打上标记的位置加1。
// 那么如何设计这个「标记」呢？由于数组中的数没有任何限制，因此这并不是一件容易的事情。
// 但我们可以继续利用上面的提到的性质：由于我们只在意[1, N]中的数，
// 因此我们可以先对数组进行遍历，把不在[1, N]范围内的数修改成任意一个大于N的数（例如N + 1）。
// 这样一来，数组中的所有数就都是正数了，因此我们就可以将「标记」表示为「负号」。

// 算法的流程如下：
// 我们将数组中所有小于等于0的数修改为N + 1
// 我们遍历数组中的每一个数x，它可能已经被打了标记，因此原本对应的数为|x|，其中||为绝对值符号。
// 如果|x|∈[1, N]，那么我们给数组中的第|x| - 1个位置的数添加一个负号。
// 注意如果它已经有负号，不需要重复添加。
// 在遍历完成之后，如果数组中的每一个数都是负数，
// 那么答案是 N + 1，否则答案是第一个正数的位置加1。

// 方法三、用数组模拟哈希表，进行优化，使空间复杂度达到o(n)级别，时间复杂度依然是o(n)

const firstMissingPositive = function (nums) {
  const n = nums.length
  // 因为我们只关心在[1,n]之间的正整数，因此先对数组遍历
  // 将其中的负数转为n+1
  for (let i = 0; i < n; i++) {
    if (nums[i] <= 0) {
      nums[i] = n + 1
    }
  }
  for (let j = 0; j < n; j++) {
    // 注意，此处一定要判断元素是否已被置为负数，如果是，则不要重复操作，否则会导致错误
    // 因为可能出现几个相同的值，而不论出现几次
    // 相同值，都应该将其指向的下标对应的值置为负值，
    // 因此这会导致错误因此重复置换，可能导致该元素值为正值，
    if (Math.abs(nums[j]) <= n && nums[Math.abs(nums[j]) - 1] > 0) {
      nums[Math.abs(nums[j]) - 1] = -nums[Math.abs(nums[j]) - 1]
    }
  }
  // 遍历处理后的数组，如果存在大于0的数，则将其下标加1后返回
  // 如果不存在大于0的数，则返回n + 1
  for (let k = 0; k < n; k++) {
    if (nums[k] > 0) {
      return k + 1
    }
  }
  return n + 1
}
